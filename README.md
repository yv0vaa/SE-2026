# CLI Shell Interpreter

[![CI](https://github.com/yv0vaa/SE-2026/actions/workflows/ci.yml/badge.svg)](https://github.com/yv0vaa/SE-2026/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Интерпретатор командной оболочки (shell) на C++17: REPL, встроенные команды, подстановка переменных, пайплайны, запуск внешних программ. Учебный проект курса «Программная инженерия» (SE-2026).

## Статус проекта

| Этап | Состояние | Описание |
|------|-----------|----------|
| **Часть 1 (архитектура)** | Выполнена | Документация в `docs/ARCHITECTURE.md`: диаграммы, поток выполнения, парсинг, подстановка до токенизации, команды, пайплайны, окружение, коды возврата. |
| **Часть 2 (реализация)** | Выполнена | Полный цикл: REPL → подстановка → лексер → парсер → построение пайплайна → исполнение. |

**Реализованная функциональность:**

- **REPL**: чтение строки, обработка, вывод, цикл до EOF или `exit`.
- **Подстановка переменных** (до токенизации): `$VAR`, `${VAR}`, `$?`; внутри одинарных кавычек не выполняется.
- **Лексер и парсер**: слова, кавычки (одинарные и двойные), `|`, присваивания (`VAR=value`, в т.ч. несколько подряд).
- **Встроенные команды**: `echo`, `cat`, `wc`, `pwd`, `grep`, `exit` (с опциональным кодом).
- **Пайплайны**: последовательное выполнение с передачей stdout одной команды в stdin следующей через буфер; пустые имена команд в пайпе пропускаются; полностью пустой пайплайн даёт диагностику и код 2.
- **Внешние программы**: поиск по PATH, `fork`/`execve`, передача окружения; stderr команды не передаётся по конвейеру.
- **Окружение**: `Environment` (get/set/unset, toEnvp), инициализация из системы, переменная `?` — код возврата последней команды.
- **Обработка ошибок**: в `processLine` все исключения перехватываются; диагностика в stderr, код возврата 1; интерпретатор не завершается из-за пользовательского ввода.

**Вне объёма (не реализовано):** фоновые задачи (`&`), перенаправление в файлы (`>`, `<`, `>>`), составные команды (`if`, `for`, `while`), история и автодополнение.

**Тесты:** 202+ юнит- и интеграционных тестов (Google Test), CI на Linux и macOS.

## Описание проекта

CLI Shell Interpreter — учебная реализация shell с конвейерной архитектурой и чётким разделением компонентов (InputReader → Substitutor → Lexer → Parser → PipelineBuilder → Executor). Подробности — в [`docs/ARCHITECTURE.md`](docs/ARCHITECTURE.md).

### Реализованные возможности

- **Встроенные команды**: `cat`, `echo`, `wc`, `pwd`, `grep`, `exit`
- **Пайплайны**: конвейер через `|` (например, `cat file.txt | wc`)
- **Переменные окружения**: подстановка `$VAR`, `${VAR}`, `$?`; присваивание `VAR=value` (и несколько подряд)
- **Внешние программы**: запуск по имени (поиск в PATH) с передачей окружения
- **Кавычки**: одинарные (без подстановки) и двойные (с подстановкой)

## Архитектура

Полное описание — [`docs/ARCHITECTURE.md`](docs/ARCHITECTURE.md). Схема потока данных:

```
┌──────────────────────────────────────────────────────────────────┐
│                         Shell (main)                             │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                      REPL Loop                              │ │
│  │                                                             │ │
│  │   ┌──────────┐    ┌────────────┐    ┌──────────────────┐    │ │
│  │   │  Input   │──▶│ Substitutor │──▶│     Lexer        │    │ │
│  │   │  Reader  │    │            │    │                  │    │ │
│  │   └──────────┘    └────────────┘    └────────┬─────────┘    │ │
│  │                                              │              │ │
│  │   ┌──────────┐    ┌────────────┐    ┌───────▼──────────┐    │ │
│  │   │ Executor │◀──│  Pipeline  │◀── │     Parser       │    │ │
│  │   │          │    │  Builder   │    │                  │    │ │
│  │   └──────────┘    └────────────┘    └──────────────────┘    │ │
│  └─────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────┘
```

## Пример использования

```bash
# Запуск интерпретатора
$ ./shell

# Пример сессии
> echo Hello, World!
Hello, World!

> FOO=bar
> echo $FOO
bar

> cat README.md | wc
  42  156  1234

> pwd
/home/user/project

> grep "Минимальный" README.md
Минимальный синтаксис grep

> grep -i "минимальный" README.md
Минимальный синтаксис grep

> grep -A 1 "II" README.md
...

> exit
```

## Библиотека разбора аргументов (grep)

Для разбора ключей команды `grep` (-w, -i, -A N) используется библиотека **CLI11** (https://github.com/CLIUtils/CLI11).

**Рассматривались варианты:**

| Библиотека | Плюсы | Минусы |
|------------|--------|--------|
| **getopt (POSIX)** | Нет зависимостей, есть в системе | Нет типизации, нет валидации, ручная обработка -A N |
| **cxxopts** | Header-only, простой API | Меньше распространена, менее богатая валидация |
| **CLI11** | Header-only, FetchContent, богатые опции и валидация, активная разработка | — |
| **Boost.Program_options** | Мощная, известная | Тяжёлая зависимость от Boost |

**Выбор:** CLI11 — header-only, подключается через CMake FetchContent, не требует установки в систему; поддерживает флаги, опции с значением и валидацию (например, неотрицательное число для -A). Определение опций grep выполняется через `add_flag` и `add_option`; паттерн и список файлов выделяются из аргументов вручную, чтобы не передавать в парсер имя программы и позиционные аргументы в одном векторе.

## Сборка и запуск

### Требования

- C++17 или новее
- CMake 3.16+
- Компилятор с поддержкой C++17 (GCC 9+, Clang 10+, MSVC 2019+)

### Сборка

```bash
# Клонирование репозитория
git clone https://github.com/yv0vaa/SE-2026.git
cd SE-2026

# Создание директории для сборки
mkdir build && cd build

# Конфигурация и сборка
cmake .. -DBUILD_TESTING=ON
cmake --build .

# Запуск тестов (190 тестов)
ctest --output-on-failure

# Запуск интерпретатора
./shell
```

### Сборка с санитайзерами (рекомендуется для разработки)

```bash
cmake -DCMAKE_BUILD_TYPE=Debug \
      -DBUILD_TESTING=ON \
      -DENABLE_SANITIZER_ADDRESS=ON \
      -DENABLE_SANITIZER_UNDEFINED_BEHAVIOR=ON \
      ..
cmake --build .
```

## Настройка окружения разработчика

### Установка git-хуков

Перед началом работы установите git-хуки для автоматических проверок:

```bash
./scripts/install-hooks.sh
```

Это установит **pre-push hook**, который перед каждым пушем:
1. ✅ Проверяет и автоматически форматирует код (`clang-format`)
2. ✅ Запускает статический анализ (`clang-tidy`)
3. ✅ Собирает проект
4. ✅ Запускает все 190 тестов

Для пропуска проверок (не рекомендуется):
```bash
git push --no-verify           # пропустить всё
SKIP_FORMAT=1 git push         # пропустить форматирование
SKIP_TIDY=1 git push           # пропустить clang-tidy
```

### Рекомендуемые инструменты

- `clang-format` — автоформатирование кода
- `clang-tidy` — статический анализ
- `cmake` 3.16+

На macOS:
```bash
brew install cmake llvm
```

На Ubuntu:
```bash
sudo apt install cmake clang-format clang-tidy
```

## Структура проекта

```
SE-2026/
├── docs/
│   └── ARCHITECTURE.md       # Архитектурная документация
├── include/
│   └── shell/                # Заголовочные файлы
│       └── commands/         # Команды
├── src/
│   └── shell/                # Исходный код
│       └── commands/         # Реализации команд
├── tests/                    # Модульные тесты (190 тестов)
├── scripts/
│   ├── install-hooks.sh      # Установка git-хуков
│   ├── pre-push              # Pre-push hook
│   └── check.sh              # Локальный скрипт проверки
├── .github/
│   └── workflows/
│       └── ci.yml            # CI конфигурация
├── CMakeLists.txt            # Конфигурация сборки
├── .clang-format             # Настройки форматирования
├── .clang-tidy               # Настройки статического анализа
└── README.md
```

## Запуск тестов

```bash
cd build

# Через CTest
ctest --output-on-failure

# Или напрямую
./shell_tests
```

План тестирования, описание покрытия по компонентам и соглашения (вход/выход для тестов) описаны в [docs/TESTING.md](docs/TESTING.md).

## Стиль кодирования

Проект следует [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html) с некоторыми исключениями:

- Отступы: 4 пробела
- Максимальная длина строки: 100 символов

Для автоматического форматирования используется `clang-format`:

```bash
# Форматирование всех файлов
find src include tests -name "*.cpp" -o -name "*.hpp" | xargs clang-format -i
```

## Лицензия

Проект распространяется под лицензией MIT. См. файл [LICENSE](LICENSE) для деталей.

## Авторы

- [Захаров Владимир](https://github.com/yv0vaa)
- [Никоненко Егор](https://github.com/animeemorave)
- [Шатохин Лев](https://github.com/TrueKotenka)

## Как помочь проекту

1. Форкните репозиторий
2. Создайте ветку для вашей функции (`git checkout -b feature/amazing-feature`)
3. Закоммитьте изменения (`git commit -m 'feat: add amazing feature'`)
4. Запушьте в ветку (`git push origin feature/amazing-feature`)
5. Откройте Pull Request

### Соглашения о коммитах

Проект следует [Conventional Commits](https://www.conventionalcommits.org/):

- `feat:` — новая функциональность
- `fix:` — исправление ошибки
- `docs:` — изменения в документации
- `test:` — добавление или изменение тестов
- `refactor:` — рефакторинг кода
- `style:` — форматирование, отступы
- `chore:` — обслуживание проекта
